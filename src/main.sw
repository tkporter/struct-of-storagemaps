contract;

use std::storage::storage_map::*;

abi ReproAttempt {
    #[storage(read, write)]
    fn foo_insert(key: u64, value: u64);

    #[storage(read)]
    fn foo_get(key: u64) -> Option<u64>;

    #[storage(read, write)]
    fn bar_insert(key: u64, value: u64);

    #[storage(read)]
    fn bar_get(key: u64) -> Option<u64>;
}

struct StructOfStorageMaps {
    foo: StorageMap<u64, u64>,
    bar: StorageMap<u64, u64>,
}

storage {
    struct_of_maps: StructOfStorageMaps = StructOfStorageMaps {
        foo: StorageMap {},
        bar: StorageMap {},
    },
}

impl ReproAttempt for Contract {
    #[storage(read, write)]
    fn foo_insert(key: u64, value: u64) {
        storage.struct_of_maps.foo.insert(key, value);
    }

    #[storage(read)]
    fn foo_get(key: u64) -> Option<u64> {
        storage.struct_of_maps.foo.get(key).try_read()
    }

    #[storage(read, write)]
    fn bar_insert(key: u64, value: u64) {
        storage.struct_of_maps.bar.insert(key, value);
    }

    #[storage(read)]
    fn bar_get(key: u64) -> Option<u64> {
        storage.struct_of_maps.bar.get(key).try_read()
    }
}

#[test()]
fn test_read_write() {
    let repro = abi(ReproAttempt, CONTRACT_ID);

    assert(repro.foo_get(1).is_none());
    repro.foo_insert(1, 2);
    assert(repro.foo_get(1).unwrap() == 2);

    // I'd expect this to give None, but it gives me Some(2) :(
    // So this test actually passes
    assert(repro.bar_get(1).unwrap() == 2);

    // I believe this is because the slot & offset in the `StorageKey` for `bar` and `foo` are the same.
    // Even if the offset for foo and bar were different (I think you can test this by
    // putting a `baz: u64` or something between foo and bar in the struct declaration),
    // I believe the storage key generated by StorageMap is just the sha of the slot & the index,
    // and doesn't consider the offset at all
}
